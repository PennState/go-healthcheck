// Code generated by additional-properties DO NOT EDIT.

package health

import (
	"encoding/json"
	"reflect"
	"strings"
)

type Valueea2f6e8a571941279831930cd1b66567 reflect.Value // DO NOT REMOVE (guarantees the reflect package is used)

// MarshalJSON encodes the ComponentDetail struct to JSON with additional-properties
func (c ComponentDetail) MarshalJSON() ([]byte, error) {
	type Alias ComponentDetail
	aux := (Alias)(c)
	if aux.AdditionalProperties == nil {
		aux.AdditionalProperties = map[string]interface{}{}
	}
	if aux.ComponentId != "" {
		aux.AdditionalProperties["componentId"] = aux.ComponentId
	}
	if aux.ComponentType != "" {
		aux.AdditionalProperties["componentType"] = aux.ComponentType
	}
	if aux.ObservedValue != nil {
		aux.AdditionalProperties["observedValue"] = aux.ObservedValue
	}
	if aux.ObservedUnit != "" {
		aux.AdditionalProperties["observedUnit"] = aux.ObservedUnit
	}
	if reflect.ValueOf(aux.Status) == reflect.Zero(reflect.TypeOf(aux.Status)) {
		aux.AdditionalProperties["status"] = aux.Status
	}
	if len(aux.AffectedEndpoints) != 0 {
		aux.AdditionalProperties["affectedEndpoints"] = aux.AffectedEndpoints
	}
	if reflect.ValueOf(aux.Time) == reflect.Zero(reflect.TypeOf(aux.Time)) {
		aux.AdditionalProperties["time"] = aux.Time
	}
	if aux.Output != "" {
		aux.AdditionalProperties["output"] = aux.Output
	}
	if len(aux.Links) != 0 {
		aux.AdditionalProperties["links"] = aux.Links
	}
	return json.Marshal(aux.AdditionalProperties)
}

// UnmarshalJSON decodes JSON into the ComponentDetail struct with additional-properties
func (c *ComponentDetail) UnmarshalJSON(data []byte) error {
	type Alias ComponentDetail
	aux := (*Alias)(c)
	err := json.Unmarshal(data, &aux)
	if err != nil {
		return err
	}
	_ = json.Unmarshal(data, &c.AdditionalProperties)
	names := map[string]bool{
		"componentId": true, "componentid": true,
		"componentType": true, "componenttype": true,
		"observedValue": true, "observedvalue": true,
		"observedUnit": true, "observedunit": true,
		"status": true,
		"affectedEndpoints": true, "affectedendpoints": true,
		"time": true,
		"output": true,
		"links": true,
	}
	for k := range c.AdditionalProperties {
		if names[k] {
			delete(c.AdditionalProperties, k)
			continue
		}
		if names[strings.ToLower(k)] {
			delete(c.AdditionalProperties, k)
		}
	}
	if len(c.AdditionalProperties) == 0 {
		c.AdditionalProperties = nil
	}
	return nil
}
